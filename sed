5. Примеры использования sed
Синтаксис команды	Описание
sed 's/Nick/John/g' report.txt
Заменяет каждое вхождение Nick на John в файле report.txt
sed 's/Nick\|nick/John/g' report.txt
Заменяет каждое вхождение Nick или nick на John.
sed 's/^/        /' file.txt > file_new.txt
Добавляет 8 пробелов слева от текста для улучшения качества печати.
sed -n '/Of course/,/attention you pay/p' myfile
Выводит все абзацы, начинающиеся с "Of course" и заканчивающиеся на "attention you pay".
sed -n 12,18p file.txt
Выводит только строки 12-18 файла file.txt
sed 12,18d file.txt
Выводит весь файл file.txt за исключением строк с 12 по 18
sed G file.txt 
Вставляет пустую строку после каждой строки в file.txt
sed -f script.sed file.txt
Записывает все команды в script.sed и выполняет их.
sed '5!s/ham/cheese/' file.txt
Заменяет ham на cheese в file.txt за исключением 5-й строки
sed '$d' file.txt
Удаляет последнюю строку
sed -n '/[0-9]\{3\}/p' file.txt
Печатает только строки с тремя последовательными цифрами
sed '/boom/s/aaa/bb/' file.txt
Если найден "boom", заменить aaa на bb
sed '17,/disk/d' file.txt
Удаляет все строки, начиная с 17-й, до "disk". Если строк с "disk" несколько, удаляет до первой из них.
echo ONE TWO | sed "s/one/unos/I"
Заменяет one на unos независимо от регистра, поэтому будет напечатано "unos TWO"
sed 'G;G' file.txt
Вставляет две пустые строки после каждой строки в file.txt
sed 's/.$//' file.txt
Способ замены dos2unix :). В общем случае удаляет последний символ в каждой строке.
sed 's/^[ \t]*//' file.txt
Удаляет все пробелы/табы перед каждой строкой в file.txt
sed 's/[ \t]*$//' file.txt
Удаляет все пробелы/табы в конце каждой строки в file.txt
sed 's/^[ \t]*//;s/[ \t]*$//' file.txt
Удаляет все пробелы/табы в начале и в конце каждой строки в file.txt
sed 's/foo/bar/' file.txt
Заменяет foo на bar только в первом вхождении в строке.
sed 's/foo/bar/4' file.txt
Заменяет foo на bar только в четвертом вхождении в строке.
sed 's/foo/bar/g' file.txt
Заменяет foo на bar для всех вхождений в строке.
sed '/baz/s/foo/bar/g' file.txt
Заменить foo на bar только если строка содержит baz.
sed '/./,/^$/!d' file.txt
Сжать все последовательные пустые строки до одной. Пустой строки сверху не остается.
sed '/^$/N;/\n$/D' file.txt
Сжать все последовательные пустые строки до одной, но оставить верхнюю пустую строку.
sed '/./,$!d' file.txt
Удалить все начальные пустые строки
sed -e :a -e '/^\n*$/{$d;N;};/\n$/ba' file.txt
Удалить все замыкающие пустые строки
sed -e :a -e '/\\$/N; s/\\\n/ /; ta' file.txt
Если строка заканчивается обратным сплешем, соединить ее со следующей (полезно для скриптов оболочки)
sed -n '/regex/,+5p' file.txt
Выводит 5 строк после строки содержащей regex
sed '1~3d' file.txt
Удалить каждую третью строку, начиная с первой.
sed -n '2~5p' file.txt
Печатать каждую пятую строку, начиная со второй.
sed 's/[Nn]ick/John/g' report.txt
Другой способ записи некоторых приведенных выше примеров. Вы можете предложить свой?
sed -n '/RE/{p;q;}' file.txt
Печатает строку с первым соответствием RE (регулярного выражения)
sed '0,/RE/{//d;}' file.txt
Удаляет строку с первым соответствием
sed '0,/RE/s//to_that/' file.txt
Изменяет только первое соответствие
sed 's/^[^,]*,/9999,/' file.csv
Заменяет на 9999 все значения в первой колонке CSV-файла
s/^ *\(.*[^ ]\) *$/|\1|/;
s/" *, */"|/g;
: loop
s/| *\([^",|][^,|]*\) *, */|\1|/g;
s/| *, */||/g;
t loop
s/ *|/|/g;
s/| */|/g;
s/^|\(.*\)|$/\1/;
Скрипт sed для конвертирования CSV-файла в файл с вертикальной чертой в качестве разделителя (работает только с некоторыми типами CSV, со встроенными кавычками и запятыми).
sed ':a;s/\(^\|[^0-9.]\)\([0-9]\+\)\([0-9]\{3\}\)/\1\2,\3/g;ta' file.txt
Меняет формат чисел в file.txt с 1234.56 на 1.234.56
sed -r "s/\<(reg|exp)[a-z]+/\U&/g"
Переводит любое слово, начинающееся с reg или exp в верхний регистр.
sed '1,20 s/Johnson/White/g' file.txt
Производит замену Johnson на White только в строках 1 - 20.
sed '1,20 !s/Johnson/White/g' file.txt
Предыдущий пример наоборот (заменяет везде, кроме строк 1-20)
sed '/from/,/until/ { s/\<red\>/magenta/g; s/<blue\>/cyan/g; }' file.txt
Заменяет только между "from" и "until". Если областей "from"-"until" несколько, заменяет в каждой из них.
sed '/ENDNOTES:/,$ { s/Schaff/Herzog/g; s/Kraft/Ebbing/g; }' file.txt
Заменяет только со слова "ENDNOTES:" и до EOF
sed '/./{H;$!d;};x;/regex/!d' file.txt
Печатает абзац только если он содержит regex
sed -e '/./{H;$!d;}' -e 'x;/RE1/!d;/RE2/!d;/RE3/!d' file.txt
Печатает абзацы только если они содержат RE1, RE2 и RE3. Порядок RE1, RE2 и RE3 не имеет значения.
sed 's/14"/fourteen inches/g' file.txt
Так вы сможете использовать двойные кавычки
sed 's/\/some\/UNIX\/path/\/a\/new\/path/g' file.txt
Работа с путями Unix
sed 's/[a-g]//g' file.txt
Удаляет все символы, начиная с a и заканчивая g из файла file.txt
sed 's/\(.*\)foo/\1bar/' file.txt
Заменяет только последнее в строке соответствие foo на bar
sed '1!G;h;$!d' 
Замена команды tac
sed '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//'
Замена команды rev
sed 10q file.txt
Замена команды head
sed -e :a -e '$q;N;11,$D;ba' file.txt
Замена команды tail
sed '$!N; /^\(.*\)\n\1$/!P; D' file.txt
Замена команды uniq
sed '$!N; s/^\(.*\)\n\1$/\1/;t; D' file.txt
Обратная команда (что эквивалентно uniq -d)
sed '$!N;$!D' file.txt
Эквивалент tail -n 2
sed -n '$p' file.txt
... tail -n 1 (или tail -1)
sed '/regexp/!d' file.txt
Эквивалент grep
sed -n '/regexp/{g;1!p;};h' file.txt
Печатает строку, находящуюся перед первым соответствием регулярному выражению, но не включающую само соответствие
sed -n '/regexp/{n;p;}' file.txt
Печатает строку, находящуюся после первого соответствия регулярному выражению, но не включающую само соответствие
sed '/pattern/d' file.txt
Удаляет строки, соответствующие шаблону pattern
sed '/./!d' file.txt
Удаляет все пустые строки из файла
sed '/^$/N;/\n$/N;//D' file.txt
Сжимает все последовательные пустые строки до двух пустых. Одинарные пустые строки не изменяются.
sed -n '/^$/{p;h;};/./{x;/./p;}' file.txt
Удаляет последнюю строку каждого абзаца
sed '/^$/q'
Получает заголовок письма. Другими словами - удаляет все после первой пустой строки.
sed '1,/^$/d'
Получает тело письма. Другими словами - удаляет все до первой пустой строки.
sed '/^Subject: */!d; s///;q'
Получает тему письма
sed 's/^/> /'
Цитирует сообщение, вставляя "> " перед каждой строкой
sed 's/^> //'
Обратная команда (убирает цитирование из сообщения)
sed -e :a -e 's/<[^>]*>//g;/</N;//ba'
Удаляет HTML-теги
 sed '/./{H;$!d;};x;s/\n/={NL}=/g' file.txt\
 | sort | sed '1s/={NL}=//;s/={NL}=/\n/g'
Сортирует абзацы в file.txt в алфавитном порядке
sed 's@/usr/bin@&/local@g' path.txt
Заменяет /usr/bin на /usr/bin/local в path.txt
sed 's@^.*$@<&>>>@g' path.txt
Попробуйте и увидите :)
sed 's/\(\/[^:]*\).*/\1/g' path.txt
При условии, что path.txt содержит $PATH, выводит только первый путь в каждой строке
sed 's/\([^:]*\).*/\1/' /etc/passwd
Замена awk - показывает только пользователей из файла passwd
echo "Welcome To The Geek Stuff" | sed 's/\(\b[A-Z]\)/\(\1\)/g' 
Понятно без объяснений - (W)elcome (T)o (T)he (G)eek (S)tuff
sed '/./{H;$!d;};x;s/\n/={NL}=/g' file.txt\
 | sed '/END$/s/hills/mountains/g'\
 | sed '1s/={NL}=//;s/={NL}=/\n/g'
Заменяет "hills" на "mountains", но только в блоках текста, начинающихся с пустой строки и заканчивающихся строкой с тремя символами "END", включительно.
sed -e '/^#/d' /etc/services | more
Показывает файл services без закомментированных строк
sed '$s@\([^:]*\):\([^:]*\):\([^:]*\)@\3:\2:\1:@g' path.txt
Меняет порядок первых трех элементов в последней строке файла path.txt на обратный
sed '/regex/{x;p;x;}' file.txt
Вставляет новую строку выше каждой строки, соответствующей регулярному выражению
sed '/AAA/!d; /BBB/!d; /CCC/!d' file.txt
Ищет строки содержащие AAA, BBB и CCC в любом порядке
sed '/AAA.*BBB.*CCC/!d' file.txt
Ищет строки содержащие AAA, BBB и CCC в заданном порядке
sed -n '/^.\{65\}/p' file.txt
Печатает строки длиной 65 символов и более
sed -n '/^.\{65\}/!p' file.txt
Печатает строки длиной 65 символов и менее
sed '/regex/G' file.txt
Вставляет пустую строку под каждой строкой, содержащей regex
sed '/regex/{x;p;x;G;}' file.txt
Вставляет пустую строку над и под каждой строкой, содержащей regex
sed = file.txt | sed 'N;s/\n/\t/'
Нумерует строки в file.txt
sed -e :a -e 's/^.\{1,78\}$/ &/;ta' file.txt
Выровнять текст по правому краю
sed -e :a -e 's/^.\{1,77\}$/ &/;ta' -e 's/\( *\)\1/\1/' file.txt
Выровнять текст по центру
